name: Auto Release

on:
  workflow_dispatch:

jobs:
  analyze-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Get latest tag
        id: get_latest_tag
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"
          
      - name: Analyze commits and determine version bump
        id: analyze_commits
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"
          
          # Get commits since last tag
          if [ "$LATEST_TAG" == "v0.0.0" ]; then
            COMMITS=$(git log --pretty=format:"%s" --no-merges)
          else
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" --no-merges)
          fi
          
          echo "Commits to analyze:"
          echo "$COMMITS"
          
          # Check if there are any commits
          if [ -z "$COMMITS" ]; then
            echo "No new commits since last tag"
            echo "should_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Determine bump type based on conventional commits
          BUMP_TYPE="patch"
          
          # Check for breaking changes (major bump)
          if echo "$COMMITS" | grep -qiE "^(feat|fix|chore|refactor|docs)(\(.+\))?!:|BREAKING CHANGE:|breaking:|^break:"; then
            BUMP_TYPE="major"
            echo "ðŸš¨ Breaking changes detected â†’ MAJOR version bump"
          # Check for features (minor bump)
          elif echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
            BUMP_TYPE="minor"
            echo "âœ¨ Features detected â†’ MINOR version bump"
          # Check for fixes, docs, refactor, chore (patch bump)
          elif echo "$COMMITS" | grep -qE "^(fix|docs|refactor|chore|style|test|perf)(\(.+\))?:"; then
            BUMP_TYPE="patch"
            echo "ðŸ› Fixes/improvements detected â†’ PATCH version bump"
          else
            echo "âš ï¸ No conventional commits detected, defaulting to PATCH bump"
            BUMP_TYPE="patch"
          fi
          
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "should_release=true" >> $GITHUB_OUTPUT
          
      - name: Calculate next version
        id: next_version
        if: steps.analyze_commits.outputs.should_release == 'true'
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"
          BUMP_TYPE="${{ steps.analyze_commits.outputs.bump_type }}"
          
          VERSION=${LATEST_TAG#v}
          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          case "$BUMP_TYPE" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Next version: $NEW_VERSION (${BUMP_TYPE} bump)"
          
      - name: Generate release notes
        id: release_notes
        if: steps.analyze_commits.outputs.should_release == 'true'
        run: |
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"
          NEW_VERSION="${{ steps.next_version.outputs.new_version }}"
          BUMP_TYPE="${{ steps.analyze_commits.outputs.bump_type }}"
          
          # Get commits since last tag
          if [ "$LATEST_TAG" == "v0.0.0" ]; then
            COMMITS=$(git log --pretty=format:"- %s" --no-merges)
          else
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s" --no-merges)
          fi
          
          # Categorize commits
          BREAKING=$(echo "$COMMITS" | grep -iE "^- (feat|fix|chore|refactor|docs)(\(.+\))?!:|BREAKING CHANGE:|breaking:" || true)
          FEATURES=$(echo "$COMMITS" | grep "^- feat" || true)
          FIXES=$(echo "$COMMITS" | grep "^- fix" || true)
          DOCS=$(echo "$COMMITS" | grep "^- docs" || true)
          REFACTOR=$(echo "$COMMITS" | grep "^- refactor" || true)
          PERF=$(echo "$COMMITS" | grep "^- perf" || true)
          CHORE=$(echo "$COMMITS" | grep "^- chore" || true)
          OTHER=$(echo "$COMMITS" | grep -v "^- feat\|^- fix\|^- docs\|^- refactor\|^- perf\|^- chore" || true)
          
          # Build release notes
          echo "## What's Changed" > release_notes.md
          echo "" >> release_notes.md
          echo "**Version bump**: ${BUMP_TYPE} (${LATEST_TAG} â†’ ${NEW_VERSION})" >> release_notes.md
          echo "" >> release_notes.md
          
          if [ -n "$BREAKING" ]; then
            echo "### âš ï¸ BREAKING CHANGES" >> release_notes.md
            echo "$BREAKING" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -n "$FEATURES" ]; then
            echo "### âœ¨ Features" >> release_notes.md
            echo "$FEATURES" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -n "$FIXES" ]; then
            echo "### ðŸ› Bug Fixes" >> release_notes.md
            echo "$FIXES" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -n "$PERF" ]; then
            echo "### âš¡ Performance" >> release_notes.md
            echo "$PERF" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -n "$REFACTOR" ]; then
            echo "### â™»ï¸ Refactoring" >> release_notes.md
            echo "$REFACTOR" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -n "$DOCS" ]; then
            echo "### ðŸ“š Documentation" >> release_notes.md
            echo "$DOCS" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -n "$CHORE" ]; then
            echo "### ðŸ”§ Chores" >> release_notes.md
            echo "$CHORE" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -n "$OTHER" ]; then
            echo "### Other Changes" >> release_notes.md
            echo "$OTHER" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          cat release_notes.md
          
      - name: Set up JDK 17
        if: steps.analyze_commits.outputs.should_release == 'true'
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'
          
      - name: Grant execute permission for scripts
        if: steps.analyze_commits.outputs.should_release == 'true'
        run: |
          chmod +x gradlew
          chmod +x update-version.sh
          
      - name: Update version in build.gradle.kts
        if: steps.analyze_commits.outputs.should_release == 'true'
        run: |
          NEW_VERSION="${{ steps.next_version.outputs.new_version }}"
          ./update-version.sh "$NEW_VERSION"
          echo "âœ… Version updated to $NEW_VERSION"
          
      - name: Create debug keystore for signing
        if: steps.analyze_commits.outputs.should_release == 'true'
        run: |
          mkdir -p ~/.android
          keytool -genkey -v -keystore ~/.android/debug.keystore -storepass android -alias androiddebugkey -keypass android -keyalg RSA -keysize 2048 -validity 10000 -dname "CN=Android Debug,O=Android,C=US"
          
      - name: Build Release APK
        if: steps.analyze_commits.outputs.should_release == 'true'
        run: |
          export JAVA_HOME="${JAVA_HOME_17_X64}"
          ./gradlew assembleRelease
        
      - name: Prepare APK for Release
        if: steps.analyze_commits.outputs.should_release == 'true'
        run: |
          cp app/build/outputs/apk/release/app-release.apk Moodroid-${{ steps.next_version.outputs.new_version }}.apk
          echo "âœ… APK prepared: Moodroid-${{ steps.next_version.outputs.new_version }}.apk"
          ls -lh Moodroid-*.apk
          
      - name: Create Release
        if: steps.analyze_commits.outputs.should_release == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.next_version.outputs.new_version }}
          name: Release ${{ steps.next_version.outputs.new_version }}
          body_path: release_notes.md
          draft: false
          prerelease: false
          files: |
            Moodroid-${{ steps.next_version.outputs.new_version }}.apk
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Summary
        if: steps.analyze_commits.outputs.should_release == 'true'
        run: |
          echo "## Release Created! ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.next_version.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous:** ${{ steps.get_latest_tag.outputs.latest_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Bump type:** ${{ steps.analyze_commits.outputs.bump_type }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Release Notes" >> $GITHUB_STEP_SUMMARY
          cat release_notes.md >> $GITHUB_STEP_SUMMARY
          
      - name: No release needed
        if: steps.analyze_commits.outputs.should_release == 'false'
        run: |
          echo "## No Release Needed" >> $GITHUB_STEP_SUMMARY
          echo "No new commits since last tag" >> $GITHUB_STEP_SUMMARY
